/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @generated
 */

/*
 * !!! GENERATED FILE !!!
 *
 * Any manual changes to this file will be overwritten. To regenerate run `yarn build`.
 */
// lint directives to let us do some basic validation of generated files

/* eslint no-undef: 'error', no-unused-vars: ['error', {vars: "local"}], no-redeclare: 'error' */

/* global $NonMaybeType, Partial, $ReadOnly, $ReadOnlyArray, $FlowFixMe */
'use strict';

function deserializeEmpty() {
  return {
    type: 'Empty',
    loc: this.addEmptyLoc()
  };
}

function deserializeMetadata() {
  return {
    type: 'Metadata',
    loc: this.addEmptyLoc()
  };
}

function deserializeFunctionLikeFirst() {
  throw new Error('FunctionLike' + ' should not appear in program buffer');
}

function deserializeProgram() {
  return {
    type: 'Program',
    loc: this.addEmptyLoc(),
    body: this.deserializeNodeList()
  };
}

function deserializeFunctionExpression() {
  return {
    type: 'FunctionExpression',
    loc: this.addEmptyLoc(),
    id: this.deserializeNode(),
    params: this.deserializeNodeList(),
    body: this.deserializeNode(),
    typeParameters: this.deserializeNode(),
    returnType: this.deserializeNode(),
    predicate: this.deserializeNode(),
    generator: this.deserializeBoolean(),
    async: this.deserializeBoolean()
  };
}

function deserializeArrowFunctionExpression() {
  return {
    type: 'ArrowFunctionExpression',
    loc: this.addEmptyLoc(),
    id: this.deserializeNode(),
    params: this.deserializeNodeList(),
    body: this.deserializeNode(),
    typeParameters: this.deserializeNode(),
    returnType: this.deserializeNode(),
    predicate: this.deserializeNode(),
    expression: this.deserializeBoolean(),
    async: this.deserializeBoolean()
  };
}

function deserializeFunctionDeclaration() {
  return {
    type: 'FunctionDeclaration',
    loc: this.addEmptyLoc(),
    id: this.deserializeNode(),
    params: this.deserializeNodeList(),
    body: this.deserializeNode(),
    typeParameters: this.deserializeNode(),
    returnType: this.deserializeNode(),
    predicate: this.deserializeNode(),
    generator: this.deserializeBoolean(),
    async: this.deserializeBoolean()
  };
}

function deserializeComponentDeclaration() {
  return {
    type: 'ComponentDeclaration',
    loc: this.addEmptyLoc(),
    id: this.deserializeNode(),
    params: this.deserializeNodeList(),
    body: this.deserializeNode(),
    typeParameters: this.deserializeNode(),
    rendersType: this.deserializeNode()
  };
}

function deserializeHookDeclaration() {
  return {
    type: 'HookDeclaration',
    loc: this.addEmptyLoc(),
    id: this.deserializeNode(),
    params: this.deserializeNodeList(),
    body: this.deserializeNode(),
    typeParameters: this.deserializeNode(),
    returnType: this.deserializeNode()
  };
}

function deserializeFunctionLikeLast() {
  throw new Error('FunctionLike' + ' should not appear in program buffer');
}

function deserializeStatementFirst() {
  throw new Error('Statement' + ' should not appear in program buffer');
}

function deserializeMatchStatement() {
  return {
    type: 'MatchStatement',
    loc: this.addEmptyLoc(),
    argument: this.deserializeNode(),
    cases: this.deserializeNodeList()
  };
}

function deserializeLoopStatementFirst() {
  throw new Error('LoopStatement' + ' should not appear in program buffer');
}

function deserializeWhileStatement() {
  return {
    type: 'WhileStatement',
    loc: this.addEmptyLoc(),
    body: this.deserializeNode(),
    test: this.deserializeNode()
  };
}

function deserializeDoWhileStatement() {
  return {
    type: 'DoWhileStatement',
    loc: this.addEmptyLoc(),
    body: this.deserializeNode(),
    test: this.deserializeNode()
  };
}

function deserializeForInStatement() {
  return {
    type: 'ForInStatement',
    loc: this.addEmptyLoc(),
    left: this.deserializeNode(),
    right: this.deserializeNode(),
    body: this.deserializeNode()
  };
}

function deserializeForOfStatement() {
  return {
    type: 'ForOfStatement',
    loc: this.addEmptyLoc(),
    left: this.deserializeNode(),
    right: this.deserializeNode(),
    body: this.deserializeNode(),
    await: this.deserializeBoolean()
  };
}

function deserializeForStatement() {
  return {
    type: 'ForStatement',
    loc: this.addEmptyLoc(),
    init: this.deserializeNode(),
    test: this.deserializeNode(),
    update: this.deserializeNode(),
    body: this.deserializeNode()
  };
}

function deserializeLoopStatementLast() {
  throw new Error('LoopStatement' + ' should not appear in program buffer');
}

function deserializeDebuggerStatement() {
  return {
    type: 'DebuggerStatement',
    loc: this.addEmptyLoc()
  };
}

function deserializeEmptyStatement() {
  return {
    type: 'EmptyStatement',
    loc: this.addEmptyLoc()
  };
}

function deserializeBlockStatement() {
  return {
    type: 'BlockStatement',
    loc: this.addEmptyLoc(),
    body: this.deserializeNodeList(),
    implicit: this.deserializeBoolean()
  };
}

function deserializeStaticBlock() {
  return {
    type: 'StaticBlock',
    loc: this.addEmptyLoc(),
    body: this.deserializeNodeList()
  };
}

function deserializeBreakStatement() {
  return {
    type: 'BreakStatement',
    loc: this.addEmptyLoc(),
    label: this.deserializeNode()
  };
}

function deserializeContinueStatement() {
  return {
    type: 'ContinueStatement',
    loc: this.addEmptyLoc(),
    label: this.deserializeNode()
  };
}

function deserializeThrowStatement() {
  return {
    type: 'ThrowStatement',
    loc: this.addEmptyLoc(),
    argument: this.deserializeNode()
  };
}

function deserializeReturnStatement() {
  return {
    type: 'ReturnStatement',
    loc: this.addEmptyLoc(),
    argument: this.deserializeNode()
  };
}

function deserializeWithStatement() {
  return {
    type: 'WithStatement',
    loc: this.addEmptyLoc(),
    object: this.deserializeNode(),
    body: this.deserializeNode()
  };
}

function deserializeSwitchStatement() {
  return {
    type: 'SwitchStatement',
    loc: this.addEmptyLoc(),
    discriminant: this.deserializeNode(),
    cases: this.deserializeNodeList()
  };
}

function deserializeLabeledStatement() {
  return {
    type: 'LabeledStatement',
    loc: this.addEmptyLoc(),
    label: this.deserializeNode(),
    body: this.deserializeNode()
  };
}

function deserializeExpressionStatement() {
  return {
    type: 'ExpressionStatement',
    loc: this.addEmptyLoc(),
    expression: this.deserializeNode(),
    directive: this.deserializeString()
  };
}

function deserializeTryStatement() {
  return {
    type: 'TryStatement',
    loc: this.addEmptyLoc(),
    block: this.deserializeNode(),
    handler: this.deserializeNode(),
    finalizer: this.deserializeNode()
  };
}

function deserializeIfStatement() {
  return {
    type: 'IfStatement',
    loc: this.addEmptyLoc(),
    test: this.deserializeNode(),
    consequent: this.deserializeNode(),
    alternate: this.deserializeNode()
  };
}

function deseria